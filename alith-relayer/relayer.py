# relayer.py

import os
import json
import time
from web3 import Web3
from dotenv import load_dotenv
import requests # Used for making web requests to IPFS and the Alith AI server

# Load environment variables from .env file
load_dotenv()

# --- Configuration from .env ---
# Make sure these variables are set in your .env file
RPC_URL = os.getenv("RPC_URL")
ALITH_ORACLE_PRIVATE_KEY = os.getenv("ALITH_ORACLE_PRIVATE_KEY")
CLAIM_MANAGER_ADDRESS = Web3.to_checksum_address(os.getenv("CLAIM_MANAGER_ADDRESS"))
FP_TOKEN_ADDRESS = Web3.to_checksum_address(os.getenv("FP_TOKEN_ADDRESS"))
RANK_BADGE_ADDRESS = Web3.to_checksum_address(os.getenv("RANK_BADGE_ADDRESS"))
ALITH_INFERENCE_SERVER_URL = os.getenv("ALITH_INFERENCE_SERVER_URL")
# Default IPFS gateway, you can change this if you use a specific one
IPFS_GATEWAY_URL = os.getenv("IPFS_GATEWAY_URL", "https://ipfs.io/ipfs/")

# --- Initialize Web3 Provider ---
# Connects to your local Hardhat node or a testnet RPC URL
w3 = Web3(Web3.HTTPProvider(RPC_URL))

if not w3.is_connected():
    print("Failed to connect to Ethereum network. Please check RPC_URL in your .env file.")
    exit() # Exit the script if connection fails
else:
    print(f"Successfully connected to RPC: {RPC_URL}")

# --- Set up Alith Oracle Account ---
# This is the Ethereum account that your relayer will use to send transactions.
# It MUST be the address that you set as the alithOracle in ClaimManager
# and as a minter in FPToken.
alith_oracle_account = w3.eth.account.from_key(ALITH_ORACLE_PRIVATE_KEY)
w3.eth.default_account = alith_oracle_account.address # Set as default sender for convenience
print(f"Alith Oracle Address: {alith_oracle_account.address}")

# --- Load Contract ABIs and Instances ---
# This function helps load the contract's "instruction manual" (ABI)
# from the JSON files generated by Hardhat.
def load_contract(address, abi_path):
    try:
        with open(abi_path, 'r') as f:
            # Load the entire JSON, then get the 'abi' key
            abi = json.load(f)['abi']
        return w3.eth.contract(address=address, abi=abi)
    except FileNotFoundError:
        print(f"Error: ABI file not found at {abi_path}. Please check the path and ensure Hardhat contracts are compiled.")
        raise # Re-raise to stop execution if essential files are missing
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from {abi_path}. Is it a valid JSON file?")
        raise
    except KeyError:
        print(f"Error: 'abi' key not found in {abi_path}. Is it a Hardhat artifact JSON?")
        raise


# --- IMPORTANT: CONFIRM THESE RELATIVE PATHS ARE CORRECT ---
# Since 'alith-relayer' and 'fracture point hyperhack' are now siblings
# inside C:\Users\HP\Documents\, we go UP one level (..) then DOWN into
# 'fracture point hyperhack'.
#
# !! ENSURE 'fracture point hyperhack' BELOW MATCHES YOUR ACTUAL HARDHAT PROJECT FOLDER NAME EXACTLY !!
CLAIM_MANAGER_ABI_PATH = '../fracture point hyperhack/artifacts/contracts/ClaimManager.sol/ClaimManager.json'
FP_TOKEN_ABI_PATH = '../fracture point hyperhack/artifacts/contracts/FPToken.sol/FPToken.json'
RANK_BADGE_ABI_PATH = '../fracture point hyperhack/artifacts/contracts/RankBadge.sol/RankBadge.json'


try:
    claim_manager = load_contract(CLAIM_MANAGER_ADDRESS, CLAIM_MANAGER_ABI_PATH)
    fp_token = load_contract(FP_TOKEN_ADDRESS, FP_TOKEN_ABI_PATH)
    rank_badge = load_contract(RANK_BADGE_ADDRESS, RANK_BADGE_ABI_PATH)
    print("Contracts loaded successfully.")
except Exception as e:
    print(f"Failed to load one or more contracts. Please check addresses, ABI paths, and file existence. Error: {e}")
    exit()


# --- Helper Function: Fetch IPFS Data ---
# This function would download the player's detailed data from IPFS.
# In a real scenario, you might add more robust error checking,
# and verify the playerDataHash against the fetched content.
def fetch_ipfs_data(url):
    print(f"Fetching data from IPFS URL: {url}")
    try:
        response = requests.get(url)
        response.raise_for_status() # Raises HTTPError for bad responses (4xx or 5xx)
        return response.json() # Assuming the IPFS data is JSON
    except requests.exceptions.RequestException as e:
        print(f"Error fetching IPFS data from {url}: {e}")
        return None # Return None if there's an error


# --- Helper Function: Call Alith AI Inference Server ---
# This simulates sending player data to your Alith AI and getting a score back.
def call_alith_inference(player_data):
    print(f"Calling Alith Inference Server at {ALITH_INFERENCE_SERVER_URL}...")
    try:
        headers = {'Content-Type': 'application/json'}
        # The 'player_data' dictionary will be sent as the body of the POST request.
        # Ensure your Alith Inference Server expects this format.
        response = requests.post(ALITH_INFERENCE_SERVER_URL, json=player_data, headers=headers, timeout=30) # 30-second timeout
        response.raise_for_status()
        result = response.json()
        print(f"Alith AI Inference Raw Result: {result}")
        # Assuming the AI server returns a JSON object with a 'karma_score' key.
        # Adjust 'karma_score' if your AI returns a different key (e.g., 'score', 'reputation').
        return result.get('karma_score', 0)
    except requests.exceptions.RequestException as e:
        print(f"Error calling Alith Inference Server: {e}")
        return 0 # Return 0 karma if AI call fails or times out


# --- Function to send a transaction ---
# This centralizes the logic for building, signing, and sending transactions.
def send_transaction(contract_function, *args):
    try:
        # Get the latest nonce for the sender account to prevent transaction conflicts
        nonce = w3.eth.get_transaction_count(alith_oracle_account.address)

        # Build the transaction using the contract function and its arguments
        tx = contract_function(*args).build_transaction({
            'from': alith_oracle_account.address,
            'nonce': nonce,
            'gas': 500000, # A generous gas limit. You might want to estimate this dynamically.
                          # w3.eth.estimate_gas(...) can be used, but start high for local testing.
            'maxFeePerGas': w3.to_wei(200, 'gwei'), # Max fee per gas (EIP-1559) - adjust based on network
            'maxPriorityFeePerGas': w3.to_wei(2, 'gwei'), # Priority fee (EIP-1559) - adjust based on network
            'chainId': w3.eth.chain_id # Ensure correct chain ID to prevent replay attacks
        })

        # Sign the transaction with the Alith Oracle's private key
        signed_tx = w3.eth.account.sign_transaction(tx, ALITH_ORACLE_PRIVATE_KEY)

        # Send the signed transaction
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        print(f"Transaction sent: {tx_hash.hex()}")

        # Wait for the transaction to be mined and get the receipt
        receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=300) # Wait up to 5 minutes for receipt
        print(f"Transaction mined in block {receipt.blockNumber}. Status: {'Success' if receipt.status == 1 else 'Failed'}")

        if receipt.status == 0:
            print("Transaction reverted on-chain.")
            # You might want to try to decode the revert reason here for more details
            # from web3._utils.exception_tools import decode_custom_error
            # print(decode_custom_error(receipt))
        return receipt.status == 1 # Return True if successful, False otherwise

    except Exception as e:
        print(f"Error sending transaction: {e}")
        return False


# --- Main Handler for Karma Evaluation Request Events ---
# This function is called every time a 'KarmaEvaluationRequested' event is detected.
def handle_karma_evaluation_request(event):
    request_id = event['args']['requestId']
    player_address = event['args']['player']
    player_data_url = event['args']['playerDataUrl']
    player_data_hash = event['args']['playerDataHash'] # Note: You might verify this later against fetched data

    print(f"\n--- New Karma Evaluation Request (ID: {request_id}) ---")
    print(f"  Player: {player_address}")
    print(f"  Data URL: {player_data_url}")
    print(f"  Data Hash: {player_data_hash.hex()}") # Convert bytes32 to hex string for display

    # 1. Fetch Player Data from IPFS
    player_data = fetch_ipfs_data(player_data_url)
    if not player_data:
        print(f"  Failed to fetch player data for request {request_id}. Skipping processing.")
        return

    # 2. Call Alith AI for Inference
    karma_score = call_alith_inference(player_data)
    print(f"  Alith AI Calculated Karma Score: {karma_score}")

    # --- Game Logic: XP Distribution and Badge Eligibility ---
    # This is where you implement YOUR GAME'S RULES.
    # The example below is a basic illustration.

    # Convert karma score to XP. Example: 1 karma point = 100 XP
    xp_to_mint = karma_score * 100
    if xp_to_mint > 0:
        print(f"  Attempting to mint {xp_to_mint} XP to {player_address}...")
        # Call FPToken.distributeRiftXP as the alithOracle
        if not send_transaction(fp_token.functions.distributeRiftXP, player_address, xp_to_mint, 0, 0):
            print(f"  Failed to mint XP for player {player_address}. Aborting badge claim for this request.")
            return # Don't proceed if XP minting fails
        else:
            print(f"  Successfully minted {xp_to_mint} XP for {player_address}.")
    else:
        print(f"  Karma score too low ({karma_score}). No XP minted.")


    # Check Player's Current XP Balance (useful for badge eligibility)
    try:
        current_xp = fp_token.functions.balanceOf(player_address).call()
        print(f"  Player {player_address} current XP: {current_xp}")
    except Exception as e:
        print(f"  Could not get current XP for player {player_address}: {e}")
        current_xp = 0 # Default to 0 if balance check fails


    # Determine Badge Eligibility and Claim (Example Logic)
    # This logic should be expanded based on your specific game's rank system.
    # Check if player has already claimed for this season
    already_claimed_this_season = claim_manager.functions.claimed(player_address, claim_manager.functions.currentSeason().call()).call()

    badge_to_mint_rank = 0
    xp_cost_for_badge = 0
    badge_uri = ""

    # Example:
    # If player's total XP is >= 1000 and they haven't claimed a badge this season,
    # they are eligible for Rank 1 (Bronze).
    if current_xp >= 1000 and not already_claimed_this_season:
        badge_to_mint_rank = 1
        xp_cost_for_badge = 500 # Example: Bronze badge costs 500 XP
        print(f"  Player {player_address} is eligible for Rank {badge_to_mint_rank} badge.")
        # Retrieve the badge URI set by the owner
        try:
            badge_uri = claim_manager.functions.getRankMetadataURI(badge_to_mint_rank).call()
            if not badge_uri:
                print(f"  Warning: No metadata URI set for Rank {badge_to_mint_rank} on ClaimManager. Using placeholder.")
                badge_uri = "ipfs://Qmbadgeuriplaceholder" # Fallback URI
        except Exception as e:
            print(f"  Error getting rank metadata URI: {e}. Using placeholder.")
            badge_uri = "ipfs://Qmbadgeuriplaceholder" # Fallback

    # Add more `elif` conditions for other ranks (e.g., Silver, Gold) based on XP thresholds
    # elif current_xp >= 2000 and not already_claimed_this_season:
    #     badge_to_mint_rank = 2
    #     xp_cost_for_badge = 1000
    #     badge_uri = claim_manager.functions.getRankMetadataURI(badge_to_mint_rank).call()


    if badge_to_mint_rank > 0:
        print(f"  Attempting to claim Rank {badge_to_mint_rank} badge for {player_address} (XP cost: {xp_cost_for_badge})...")
        # Call ClaimManager.claimBadge as the alithOracle
        if send_transaction(claim_manager.functions.claimBadge, player_address, xp_cost_for_badge, badge_uri):
            print(f"  Successfully claimed Rank {badge_to_mint_rank} badge for {player_address}.")
        else:
            print(f"  Failed to claim Rank {badge_to_mint_rank} badge for {player_address}.")
    else:
        print(f"  Player {player_address} not eligible for a new badge at this time (Current XP: {current_xp}, Already claimed this season: {already_claimed_this_season}).")

    print(f"--- Finished processing request {request_id} ---")


# --- Main Loop of the Relayer ---
# This loop continuously checks for new events.
def main():
    # Create an event filter for KarmaEvaluationRequested events starting from the latest block.
    # This means it will only process new events that occur after the relayer starts.
    event_filter = claim_manager.events.KarmaEvaluationRequested.create_filter(from_block='latest')
    print("Relayer started. Listening for KarmaEvaluationRequested events...")

    while True:
        try:
            # Get new events that have occurred since the last check
            new_entries = event_filter.get_new_entries()
            for event in new_entries:
                handle_karma_evaluation_request(event) # Process each new event
            time.sleep(5) # Wait for 5 seconds before checking for new events again
        except KeyboardInterrupt:
            print("Relayer stopped by user (Ctrl+C).")
            break # Exit the loop if Ctrl+C is pressed
        except requests.exceptions.ConnectionError as e:
            print(f"Connection error (e.g., Alith AI server or RPC down): {e}. Retrying in 10 seconds...")
            time.sleep(10)
        except Exception as e:
            print(f"An unexpected error occurred in the main loop: {e}. Retrying in 10 seconds...")
            time.sleep(10)

if __name__ == "__main__":
    main()